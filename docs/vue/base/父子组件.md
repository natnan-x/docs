# Vue 父子组件传值与方法调用（详解）

> 本文围绕 Vue3（Composition API + `<script setup>`）详细说明父子组件之间的数据传递与方法调用方式。示例均使用 TypeScript。包含：`props`、`emit`、`v-model`、`ref` + `expose`、`provide/inject`、事件总线（mitt）与状态管理（Pinia）等实用方案与最佳实践。

## 目录

1. 父传子：`props`（单向）
2. 子传父：`emit`（事件回调）
3. 双向绑定：`v-model`（组件自定义）
4. 父调用子方法：`ref` + `defineExpose`
5. 深层传递：`provide` / `inject`
6. 跨层/跨组件通信：事件总线（mitt）与状态管理（Pinia）
7. 实战注意与最佳实践

## 1. 父传子：`props`（单向）

**核心要点**：父组件通过 `props` 向子组件下发数据。子组件应视 `props` 为只读。若需修改，子组件应发出事件或拷贝到局部 state。

**子组件定义 props（TypeScript + `<script setup>`）**：

```vue
<!-- Child.vue -->
<template>
  <div>
    <h3>{{ title }}</h3>
    <p>count: {{ count }}</p>
  </div>
</template>

<script setup lang="ts">
import { defineProps } from 'vue';

const props = defineProps<{
  title: string;
  count?: number;
}>();
</script>
```

**父组件传值**：

```vue
<!-- Parent.vue -->
<template>
  <Child title="Hello" :count="num" />
</template>

<script setup lang="ts">
import { ref } from 'vue';
import Child from './Child.vue';
const num = ref(10);
</script>
```

**注意**：不要在子组件中直接写 `props.count = 1`。若需内部修改，请拷贝到 `ref` 或 `reactive` 并修改拷贝。

## 2. 子传父：`emit`（事件回调）

**核心要点**：子组件通过 `emit` 触发事件通知父组件，父组件在模板上监听事件并处理。

**子组件发射事件**：

```vue
<!-- CounterChild.vue -->
<template>
  <button @click="inc">+1</button>
</template>

<script setup lang="ts">
import { defineEmits, defineProps } from 'vue';

const props = defineProps<{ initial?: number }>();
const emit = defineEmits<{
  (e: 'update', value: number): void;
}>();

let n = props.initial ?? 0;
function inc() {
  n++;
  emit('update', n);
}
</script>
```

**父组件监听事件**：

```vue
<template>
  <CounterChild :initial="5" @update="handleUpdate" />
</template>

<script setup lang="ts">
import { ref } from 'vue';
import CounterChild from './CounterChild.vue';
const value = ref(5);
function handleUpdate(newVal: number) {
  value.value = newVal;
}
</script>
```

**说明**：`defineEmits` 可以配合 TypeScript 类型签名，增强类型检查。

## 3. 双向绑定：`v-model`（组件自定义）

**核心要点**：在自定义组件上使用 `v-model`，实质是绑定 `modelValue` prop 并监听 `update:modelValue` 事件。可自定义 prop 名称（`v-model:foo`）。

**子组件实现（默认 `v-model` 支持）**：

```vue
<!-- TextInput.vue -->
<template>
  <input :value="modelValue" @input="onInput" />
</template>

<script setup lang="ts">
import { defineProps, defineEmits } from 'vue';

const props = defineProps<{ modelValue: string }>();
const emit = defineEmits(['update:modelValue']);

function onInput(e: Event) {
  const val = (e.target as HTMLInputElement).value;
  emit('update:modelValue', val);
}
</script>
```

**父组件使用**：

```vue
<template>
  <TextInput v-model="name" />
</template>

<script setup lang="ts">
import { ref } from 'vue';
import TextInput from './TextInput.vue';
const name = ref('');
</script>
```

**自定义 prop 名称**：

- 使用 `v-model:checked` 对应 `checked` prop 与 `update:checked` 事件。

## 4. 父调用子方法：`ref` + `defineExpose`（或 `expose`）

**核心要点**：父组件可通过模板 ref 获取子组件实例。子组件需 `defineExpose` 导出方法或数据，父组件通过 `ref.value` 调用。

**子组件导出方法**：

```vue
<!-- ChildWithApi.vue -->
<template>
  <div>子组件</div>
</template>

<script setup lang="ts">
import { ref, defineExpose } from 'vue';

const txt = ref('hello');
function focus() {
  console.log('focus called');
}

defineExpose({ focus, txt });
</script>
```

**父组件调用**：

```vue
<template>
  <ChildWithApi ref="cRef" />
  <button @click="callChild">调用子方法</button>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import ChildWithApi from './ChildWithApi.vue';
const cRef = ref<InstanceType<typeof ChildWithApi> | null>(null);
function callChild() {
  // cRef.value?.focus() // ts 类型上需要适配，直接 any 也可
  (cRef.value as any)?.focus();
}
</script>
```

**注意**：`defineExpose` 只会暴露你声明的接口。避免滥用，保持组件封装。

## 5. 深层传递：`provide` / `inject`

**核心要点**：`provide/inject` 适合祖孙组件或跨多层传参的场景。注意：`inject` 是弱引用，默认不会触发响应式更新，需传递 `ref`/`reactive` 或 `readonly`。

**祖先组件提供值**：

```vue
<!-- GrandParent.vue -->
<script setup lang="ts">
import { provide, ref } from 'vue';
const user = ref({ name: 'natnan', id: 1 });
provide('user', user);
</script>
```

**子孙组件注入并使用**：

```vue
<script setup lang="ts">
import { inject } from 'vue';
const user = inject('user') as Ref<{ name: string; id: number }> | undefined;
console.log(user?.value.name);
</script>
```

**说明**：若想响应式共享，请 `provide` 一个 `ref` 或 `reactive` 对象。

## 6. 跨层/跨组件通信：事件总线（mitt）与状态管理（Pinia）

### 6.1 事件总线（mitt）

**说明**：轻量级事件总线，可用于解耦组件。但在大型项目中不推荐作为主通信机制，优先使用状态管理。

```ts
// bus.ts
import mitt from 'mitt';
export const bus = mitt();
```

```vue
// A.vue
<script setup lang="ts">
import { bus } from './bus';
bus.emit('login', { userId: 1 });
</script>

// B.vue
<script setup lang="ts">
import { bus } from './bus';
bus.on('login', (payload) => console.log(payload));
</script>
```

### 6.2 状态管理（Pinia 推荐）

**说明**：对于跨组件共享状态，使用 Pinia 更可维护，具备类型支持与插件生态。

```ts
// store/user.ts
import { defineStore } from 'pinia';
export const useUserStore = defineStore('user', {
  state: () => ({ name: '', token: '' }),
  actions: {
    setUser(data: any) {
      Object.assign(this, data);
    },
  },
});
```

```vue
// AnyComponent.vue
<script setup lang="ts">
import { useUserStore } from '@/stores/user';
const user = useUserStore();
user.setUser({ name: 'natnan', token: 'abc' });
</script>
```

**优点**：明确的数据流、便于调试、支持插件与持久化。

## 7. 实战注意与最佳实践

- **首选 Props+Emit**：父子直接通信首选 `props`（父 → 子）和 `emit`（子 → 父），保持单向数据流清晰。
- **避免直接修改 props**：若需要修改，创建局部 state 或通过事件通知父组件。
- **使用 v-model 简化表单**：对表单和表单控件使用 `v-model`，保持 API 一致性。
- **谨慎使用事件总线**：中小型项目可临时使用，长期应迁移至 Pinia/Vuex。
- **使用 defineExpose 有控制地暴露 API**：仅暴露必要方法，保持组件封装性。
- **响应式 provide**：若需要跨层响应式更新，`provide` 应传递 `ref` 或 `reactive`。
- **Key 与 v-for**：列表渲染时为保证正确 diff，务必提供稳定且唯一的 `:key`。
- **类型安全**：在 TS 项目中为 `props`、`emit`、store 等声明类型，提高可维护性。

## 结语

父子组件通信在 Vue 开发中非常常见。掌握 `props`、`emit`、`v-model` 与 `ref`+`defineExpose` 能覆盖绝大多数场景。对于跨多层或跨模块通信，选择 `provide/inject`（小范围）或 Pinia（全局）更合适。

如果你要我把此文档直接写入你的 VitePress `/docs` 目录中，文件名为 `vue-parent-child-communication.md`，我已经生成并保存好了。
