# Vue-Router 实现原理

Vue-Router 是 Vue 官方提供的路由管理器，其核心原理是通过 **监听浏览器地址变化** 来动态渲染组件，并结合 Vue 的响应式系统实现页面的切换。下面详细分析。

## 1. 核心组成

### 1.1 路由配置对象

- `routes` 数组：存放每个路由对应的 `path` 和组件 `component`。
- 每个路由配置会在创建 `Router` 实例时注册。

### 1.2 路由实例（Router）

- 创建 `Router` 实例时，会初始化路由模式（Hash 或 History）
- 提供全局 API，如 `push`、`replace`、`beforeEach` 等。

### 1.3 路由视图（<router-view/>）

- `<router-view/>` 是路由出口，内部通过 Vue 的响应式系统监听当前路由状态。
- 当路由改变时，会渲染对应的组件。

### 1.4 路由守卫

- 全局守卫、路由独享守卫、组件内守卫，本质都是在路由切换时触发的回调函数。
- 可以通过 `next()` 控制路由的跳转逻辑。

## 2. 工作原理步骤

1. **路由实例化**：创建 `router` 对象，初始化模式、路由表、当前路由状态。
2. **地址监听**：

   - **Hash 模式**：监听 `window.onhashchange` 事件。
   - **History 模式**：监听 `popstate` 事件。

3. **更新路由状态**：

   - 当地址发生变化时，更新路由实例中的 `currentRoute`。

4. **响应式渲染**：

   - `<router-view>` 通过 Vue 响应式系统监听 `currentRoute`，动态渲染匹配的组件。

5. **触发路由守卫**：

   - 在切换前执行 `beforeEach` 或路由独享守卫，允许拦截、重定向或取消导航。

6. **完成导航**：

   - 当前路由状态更新完成后，渲染对应组件，调用组件内守卫 `beforeRouteEnter`。

## 3. 响应式机制

- `router.currentRoute` 是一个响应式对象。
- `<router-view>` 依赖 `currentRoute.value.matched` 渲染对应组件。
- Vue 3 使用 Proxy 对象实现响应式，保证路由变化时自动更新视图。

## 4. Hash 与 History 区别在原理上的体现

| 模式    | 原理              | 地址监听方式        | 页面刷新效果                      |
| ------- | ----------------- | ------------------- | --------------------------------- |
| Hash    | URL `#` 变化      | window.onhashchange | 不会 404，服务器不关心 `#` 后内容 |
| History | HTML5 History API | window.popstate     | 页面刷新需服务器配置，否则 404    |

## 5. 总结

- Vue-Router 核心依赖 Vue 响应式系统 + 浏览器事件监听实现组件切换。
- 核心原理：路由实例 + 地址监听 + 响应式渲染 + 路由守卫。
- 理解其原理有助于掌握导航拦截、动态路由和路由性能优化。

## 6. 示例代码

```js
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// 全局守卫示例
router.beforeEach((to, from, next) => {
  console.log('导航触发：', to.path);
  next();
});

export default router;
```
