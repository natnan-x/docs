# Vue2 与 Vue3 底层原理与 Diff 算法对比

## 一、核心架构演进

| 对比项            | Vue2                               | Vue3                                         |
| ----------------- | ---------------------------------- | -------------------------------------------- |
| **响应式实现**    | `Object.defineProperty()` 劫持属性 | `Proxy` 深层代理整个对象                     |
| **数据追踪机制**  | 递归遍历所有属性定义 getter/setter | 懒代理（访问时才追踪）                       |
| **依赖收集**      | `Dep` 与 `Watcher` 组合            | `effect` + `track` + `trigger` 函数机制      |
| **组件实例结构**  | Options API（基于 this）           | Composition API（基于函数作用域）            |
| **虚拟 DOM 实现** | 基于 `snabbdom` 简化版             | 重写 Virtual DOM，优化静态节点和动态节点分区 |
| **Diff 算法**     | 双端比较 + 同层 Diff               | 增加 `PatchFlag` 标记优化更新                |
| **模板编译优化**  | 无静态标记                         | 编译阶段静态提升、预字符串化                 |
| **Tree-Shaking**  | 不支持                             | 支持（按需打包，更轻量）                     |

---

## 二、Vue 响应式原理

### Vue2 响应式：`Object.defineProperty()`

```js
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      console.log(`get ${key}:`, val);
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        console.log(`set ${key}:`, val);
        // 通知视图更新
      }
    },
  });
}

const data = { name: 'vue2' };
defineReactive(data, 'name', data.name);
data.name = 'changed'; // 触发 set
```

**问题：**

- 不能监听对象新增/删除属性。
- 数组需重写原型方法（如 push/splice）。
- 深层递归监听性能差。

---

### Vue3 响应式：`Proxy` + `Reflect`

```js
const handler = {
  get(target, key, receiver) {
    const res = Reflect.get(target, key, receiver);
    console.log(`get ${key}:`, res);
    return typeof res === 'object' ? reactive(res) : res;
  },
  set(target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver);
    console.log(`set ${key}:`, value);
    return res;
  },
};

function reactive(obj) {
  return new Proxy(obj, handler);
}

const state = reactive({ name: 'vue3', nested: { age: 10 } });
state.name = 'changed';
state.nested.age = 20;
```

**优势：**

- 无需递归，天然支持深层监听。
- 能监听属性新增、删除、数组索引变化。
- 可更好配合 `Reflect` 实现精准依赖追踪。

---

## 三、依赖收集机制对比

| 机制组成     | Vue2                             | Vue3                        |
| ------------ | -------------------------------- | --------------------------- |
| **依赖容器** | `Dep`                            | `targetMap`（WeakMap 结构） |
| **依赖函数** | `Watcher`                        | `effect(fn)`                |
| **收集函数** | `getter` 内部调用 `Dep.depend()` | `track(target, key)`        |
| **触发函数** | `setter` 内部调用 `Dep.notify()` | `trigger(target, key)`      |

### Vue3 依赖追踪伪代码

```js
let activeEffect;
function effect(fn) {
  activeEffect = fn;
  fn();
  activeEffect = null;
}

function track(target, key) {
  const depsMap = targetMap.get(target) || new Map();
  const dep = depsMap.get(key) || new Set();
  dep.add(activeEffect);
  depsMap.set(key, dep);
  targetMap.set(target, depsMap);
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  const dep = depsMap.get(key);
  dep.forEach((effect) => effect());
}
```

---

## 四、Diff 算法核心

### 1. Vue2 Diff 思想

- 基于 **Snabbdom** 实现。
- 使用“双端指针算法”比较新旧子节点。
- 只比较**同层节点**，不同层级直接销毁重建。
- 通过 `key` 优化重排。

#### 核心逻辑

```text
旧首 vs 新首
旧尾 vs 新尾
旧首 vs 新尾
旧尾 vs 新首
否则用 key 查找复用节点
```

#### 特点

- O(n) 时间复杂度。
- 适合中小规模虚拟树。

---

### 2. Vue3 Diff 思想

- 引入 **PatchFlag**：编译阶段标记动态节点。
- 静态节点不再参与 Diff。
- 子节点分为三类：静态、动态、Fragment。
- 使用 **最长递增子序列（LIS）** 优化 DOM 移动。

#### PatchFlag 示例

```js
<div>{{ msg }}</div>
```

编译后生成：

```js
createVNode('div', null, toDisplayString(msg), PatchFlags.TEXT);
```

只更新带动态标记的节点，静态节点跳过。

#### LIS 优化说明

Vue3 在 Diff 阶段通过计算新旧子节点索引的**最长递增子序列**，只移动必要节点，从而减少 DOM 操作次数。

---

## 五、性能与内存优化对比

| 优化方向            | Vue2         | Vue3                  |
| ------------------- | ------------ | --------------------- |
| **依赖追踪**        | 全量递归     | 懒加载、按需追踪      |
| **虚拟 DOM 更新**   | 无静态标记   | 静态提升 + PatchFlag  |
| **组件更新粒度**    | 粗（组件级） | 细（依赖精确追踪）    |
| **打包体积**        | 较大         | Tree-Shaking 减小体积 |
| **TypeScript 支持** | 不友好       | 原生支持              |

---

## 六、总结

| 项目       | Vue2                  | Vue3                   | 改进点                  |
| ---------- | --------------------- | ---------------------- | ----------------------- |
| 响应式核心 | Object.defineProperty | Proxy                  | 支持深层监听，性能更优  |
| Diff 算法  | 双端比较              | PatchFlag + LIS        | 精准更新，减少 DOM 操作 |
| 依赖管理   | Watcher + Dep         | effect + track/trigger | 更清晰、更细粒度        |
| 模板编译   | 无静态标记            | 静态提升               | 减少运行时计算          |
| 体积       | 较大                  | 模块化、Tree-Shaking   | 体积更小                |
| TypeScript | 支持差                | 原生支持               | 类型安全增强            |

---

## 七、面试要点总结

1. **Vue3 为什么更快？**

   - 使用 Proxy 替代 defineProperty。
   - 静态提升 + PatchFlag 优化 Diff。
   - 依赖追踪更精确。

2. **Diff 算法复杂度？**

   - Vue2 和 Vue3 均为 O(n)，但 Vue3 通过静态标记减少遍历范围。

3. **Vue3 的响应式系统是如何工作的？**

   - 通过 effect 收集依赖，track 建立映射，trigger 精准触发更新。

4. **最长递增子序列（LIS）在 Vue3 中作用？**
   - 确定最少 DOM 移动路径，提高性能。

---

> ✅ **结论**：Vue3 在底层通过 Proxy、PatchFlag 和静态提升，使响应式系统与虚拟 DOM 更新更高效，内存占用更低，适合现代大型前端项目。
