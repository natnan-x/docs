<!--
 * @Author: NanNan
 * @Date: 2025-10-31 20:37:50
 * @LastEditTime: 2025-10-31 22:49:31
 * @Description:
-->

# ES6/ES7/ES8 有哪些新特性

## ES6

### 1. 变量声明

- `let` 和 `const`：块级作用域，不存在变量提升
- `const` 声明常量，引用不可变。

```ts
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
} // 输出 0,1,2
```

##### 追问点：

- let、const、var 的区别？
- const 声明对象后能改属性吗？（能改属性，不能改引用）

### 2. 模版字符串

- 使用反引号： `
- 可内插变量：`Hello ${name}`
- 字符串拼接与多行文本

```ts
const name = 'natnan';
console.log(`Hello, ${name}!`);
// 嵌套表达式如下：
const a = 5;
const b = 10;
console.log(`Sum of ${a} and ${b} is ${a + b}`);
// 调用函数如下：
function greet(name: string) {
  return `Hello, ${name}!`;
}
const user = 'natnan';
console.log(`Message: ${greet(user)}`); // 输出: Message: Hello, natnan!
```

##### 追问点：

- 模板字符串能嵌套表达式或函数调用吗？（能）

### 3. 解构赋值

对数组或对象快速取值：

```js
const [a, b] = [1, 2];
const { name, age } = person;
```

##### 追问点：

- 默认值在什么条件下生效？（解构值为 undefined 时）

### 4. 箭头函数

- 简化函数书写
- 不绑定`this`，不可用做构造函数：

```ts
const add = (x: number, y: number) => x + y;
```

### 5. 默认参数、剩余参数、扩展运算符

```ts
function sum(a: number, b: number = 1, ...rest: number[]) {
  return a + b + rest.reduce((x, y) => x + y, 0);
}
console.log(sum(1, 2, 3, 4)); // 10
```

##### 追问点：

- 展开运算符在数组与对象中的应用？
- rest 参数与 arguments 的区别？
  - rest 是真正数组，arguments 类数组

### 6. Promise

异步编程新方案，支持链式调用与错误捕获。

```ts
new Promise((resolve, reject) => {
  setTimeout(() => resolve('done'), 1000);
})
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```

##### 追问点：

- Promise 的三种状态？（pending、fulfilled、rejected）
- 如何中断 Promise 链？（返回一个不再 then 的 Promise）

### 7. 模块化 import/export

`export` 与 `import`：

```ts
// module.ts
export const a = 10;
export default function sayHi() {
  console.log('hi');
}
// main.ts
import sayHi, { a } from './module';
```

##### 追问点：

- default 与具名导出区别？
- 静态与动态导入区别？（import() 是动态导入）

### 8. 类（class）与继承（extends）

```ts
class Person {
  constructor(public name: string) {}
  say() {
    console.log(this.name);
  }
}
class Student extends Person {
  constructor(name: string, public grade: number) {
    super(name);
  }
}
```

##### 追问点：

- class 语法糖与原型继承关系？
- 子类必须调用 super 的原因？（继承自父类构造函数）

### 9. Symbol 类型

创建唯一值，常用于对象属性防冲突。

```ts
const id = Symbol('id');
const obj = { [id]: 123 };
console.log(obj[id]); // 123
```

##### 追问点：

- Symbol 属性能被 Object.keys() 枚举吗？（不能）
- Symbol 的典型应用？（定义唯一 key、防冲突）

### 10. Map / Set

新的数据结构，用于键值对和去重。

```ts
const set = new Set([1, 2, 2, 3]);
console.log(set.size); // 3
const map = new Map();
map.set('a', 1).set('b', 2);
```

##### 追问点：

- Map 与 Object 的区别？（Map key 可为任意类型）
- Set 如何实现数组去重？（[...new Set(arr)]）

### 11. WeakMap / WeakSet

```ts
const wm = new WeakMap();
wm.set({}, 'meta');
const ws = new WeakSet();
ws.add({});
```

##### 追问点：

- 弱引用、不可遍历、场景（内存泄漏防护）

### 12. Proxy

```ts
const proxy = new Proxy(
  {},
  {
    get(target, prop) {
      return prop in target ? target[prop] : 0;
    },
  }
);
```

##### 追问点：

- `Proxy` vs `Object.defineProperty`，常用 trap（get/set/apply/construct）

### 13. Reflect

配合 `Proxy` 使用，提供对象操作的默认行为

```ts
const obj = { a: 1 };
Reflect.get(obj, 'a'); // 1
Reflect.set(obj, 'b', 2);
```

##### 追问点：

- `Proxy` 与 `Reflect` 配合场景（Vue3 响应式实现）

### 14. Iterator / Generator

可迭代协议与惰性执行函数（`function*`、`yield`）。

```ts
function* gen() {
  yield 1;
  yield 2;
  return 3;
}
for (const v of gen()) console.log(v);
```

##### 追问点：

- Generator 的应用场景？（异步流程控制、惰性序列）
- Iterator 与 Iterable 的关系？

### 15. 新的内置方法

##### 常见：

- `Object.assign()`：将一个或多个源对象的可枚举属性复制到目标对象，返回目标对象（浅拷贝）。

  ```ts
  const target = { a: 1 };
  const source = { b: 2, c: 3 };
  Object.assign(target, source);
  console.log(target); // { a: 1, b: 2, c: 3 }
  ```

- `Object.entries()`：返回对象自身可枚举属性的 [key, value] 数组。

  ```ts
  const obj = { a: 1, b: 2 };
  console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]
  ```

- `Array.from()`：将类数组或可迭代对象转换为数组，可传映射函数。

  ```ts
  const set = new Set([1, 2, 3]);
  const arr = Array.from(set, (x) => x * 2);
  console.log(arr); // [2, 4, 6]
  ```

- `Array.includes()`：判断数组是否包含某个元素，返回布尔值。

  ```ts
  const arr = [1, 2, 3];
  console.log(arr.includes(2)); // true
  console.log(arr.includes(4)); // false
  ```

- `String.startsWith() / endsWith()`：判断字符串是否以某前缀开头或以某后缀结尾。

  ```ts
  const str = 'Hello World';
  console.log(str.startsWith('Hello')); // true
  console.log(str.endsWith('World')); // true
  //可选参数：指定搜索起始位置 str.startsWith('World', 6)。
  ```

- `Number.isNaN()`：判断值是否严格为 `NaN`（比全局 `isNaN` 更准确）。
  ```ts
  console.log(Number.isNaN(NaN)); // true
  console.log(Number.isNaN('NaN')); // false
  console.log(Number.isNaN(undefined)); // false
  ```

## ES7

ES7（也叫 ES2016）相比 ES6 更新不多，主要有两个核心特性：

### 1. `Array.prototype.includes()`

<b>作用：</b>判断数组是否包含某个元素，返回布尔值。

```ts
const arr = [1, 2, 3];
console.log(arr.includes(2)); // true
console.log(arr.includes(4)); // false
```

<b>区别：</b>比 `indexOf` 更直观，不受 `NaN` 的问题影响（`indexOf(NaN)` 会返回 -1）。

### 2. 指数操作符（Exponentiation Operator）

<b>作用：</b>幂运算，替代 `Math.pow()`。

```ts
console.log(2 ** 3); // 8
console.log(4 ** 0.5); // 2
console.log(Math.pow(3, 4)); // 81，与 3 ** 4 相同
```

::: info 说明
ES7 就这两个特性，其他更复杂的语法改进要到 ES8/ES2017 及以后才出现。
:::

## ES8

ES8（也叫 ES2017）相比 ES7，增加了几个实用特性，常见面试点如下：

### 1. `Object.values()` / `Object.entries()`

<b>作用：</b>获取对象的值或键值对数组。

```ts
const obj = { a: 1, b: 2 };

console.log(Object.values(obj)); // [1, 2]
console.log(Object.entries(obj)); // [['a',1], ['b',2]]
```

<b>面试追问：</b>

- 与 `Object.keys()` 区别？（keys 返回键数组，values 返回值数组，entries 返回键值对数组）

### 2. String padding（`padStart` / `padEnd`）

<b>作用：</b>补全字符串到指定长度。

```ts
console.log('5'.padStart(3, '0')); // '005'
console.log('5'.padEnd(3, '0')); // '500'
```

<b>面试追问：</b>

- 常用于格式化数字、表格对齐等场景。

### 3.`Async` / `Await`

<b>作用：</b>基于 `Promise` 的异步语法糖，简化异步代码。

```ts
function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function run() {
  console.log('Start');
  await delay(1000);
  console.log('End'); // 1 秒后输出
}
run();
```

<b>面试追问：</b>

- `async` 函数返回值类型？（始终返回 `Promise`）
- `await` 后面可以跟哪些类型？（`Promise` 或普通值）
