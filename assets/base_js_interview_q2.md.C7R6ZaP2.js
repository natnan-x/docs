import{_ as i,c as a,o as n,ah as l}from"./chunks/framework.D_x7hp0y.js";const o=JSON.parse('{"title":"说说你对闭包的理解","description":"","frontmatter":{},"headers":[],"relativePath":"base/js/interview/q2.md","filePath":"base/js/interview/q2.md","lastUpdated":1763368640000}'),e={name:"base/js/interview/q2.md"};function t(h,s,k,p,r,d){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="说说你对闭包的理解" tabindex="-1">说说你对闭包的理解 <a class="header-anchor" href="#说说你对闭包的理解" aria-label="Permalink to “说说你对闭包的理解”">​</a></h1><h2 id="一、闭包的定义" tabindex="-1">一、闭包的定义 <a class="header-anchor" href="#一、闭包的定义" aria-label="Permalink to “一、闭包的定义”">​</a></h2><p><strong>闭包是指函数可以访问它定义时的外部作用域变量，即使外层函数已经执行完。闭包的核心是作用域链，让外层变量在函数生命周期内保持可访问。</strong></p><h2 id="二、闭包的定义" tabindex="-1">二、闭包的定义 <a class="header-anchor" href="#二、闭包的定义" aria-label="Permalink to “二、闭包的定义”">​</a></h2><p>每个函数在创建时会形成一个 <strong>作用域链</strong>，这个作用域链会保留对外层变量的引用。<br> 只要闭包存在，外层函数的变量就不会被销毁。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 外部变量</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inner;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// outer 执行完了</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span></code></pre></div><ul><li>虽然 <code>outer()</code> 已经执行完，<code>count</code> 仍然被 <code>inner</code> 保存着。</li><li>每次调用 <code>fn()</code>，<code>count</code> 都会累加。</li></ul><h2 id="三、闭包的特点" tabindex="-1">三、闭包的特点 <a class="header-anchor" href="#三、闭包的特点" aria-label="Permalink to “三、闭包的特点”">​</a></h2><ul><li>闭包的缺点或注意事项？ <ul><li>会增加内存占用，因为外层变量不会被销毁。</li><li>作用域链查找会稍微慢，但现代浏览器优化很好。</li></ul></li><li>闭包在实际项目的应用？ <ul><li>封装私有变量（模块化设计）</li><li>记忆函数（缓存计算结果）</li><li>异步回调中保持循环变量（如 for 循环里的 setTimeout）</li></ul></li></ul>`,9)])])}const c=i(e,[["render",t]]);export{o as __pageData,c as default};
